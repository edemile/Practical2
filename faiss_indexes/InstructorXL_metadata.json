[["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_0", "3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_1", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_2", "Spring 2022, Notes and Examples: AVL Trees ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_3", "Spring 2022. | News | Course Reference | Schedule | Project Guide | Notes and Examples | Reinforcement Exercises | Grade Calculator | About Alex ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_4", "Spring 2022."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_5", "Notes and Examples: AVL Trees Why we must care about binary search tree balancing We've seen previously that the performance characteristics of binary search trees can vary rather wildly, and that they're mainly dependent on the shape of the tree, with the height of the tree being the key determining factor."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_6", "By definition, binary search trees restrict what keys are allowed to present in which nodes \u2014 smaller keys have to be in left subtrees and larger keys in right subtrees \u2014 but they specify no restriction on the tree's shape, meaning that both of these are perfectly legal binary search trees containing the keys 1, 2, 3, 4, 5, 6, and 7."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_7", "Yet, while both of these are legal, one is better than the other, because the height of the first tree (called a perfect binary tree) is smaller than the height of the second (called a degenerate tree)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_8", "These two shapes represent the two extremes \u2014 the best and worst possible shapes for a binary search tree containing seven keys."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_9", "Of course, when all you have is a very small number of keys like this, any shape will do."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_10", "But as the number of keys grows, the distinction between these two tree shapes becomes increasingly vital."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_11", "What's more, the degenerate shape isn't even necessarily a rare edge case: It's what you get when you start with an empty tree and add keys that are already in order, which is a surprisingly common scenario in real-world programs."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_12", "For example, one very obvious algorithm for generating unique integer keys \u2014 when all you care about is that they're unique \u2014 is to generate them sequentially. https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 1/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_13", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_14", "Spring 2022, Notes and Examples: AVL Trees What's so bad about a degenerate tree, anyway?"], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_15", "Just looking at a picture of a degenerate tree, your intuition should already be telling you that something is amiss."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_16", "In particular, if you tilt your head 45. degrees to the right, they look just like linked lists; that perception is no accident, as they behave like them, too (except that they're more complicated, to boot!)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_17", "From a more analytical perspective, there are three results that should give us pause: Every time you perform a lookup in a degenerate binary search tree, it will take O(n) time, because it's possible that you'll have to reach every node in the tree before you're done."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_18", "As n grows, this is a heavy burden to bear."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_19", "If you implement your lookup recursively, you might also be using O(n) memory, too, as you might end up with as many as n frames on your run-time stack \u2014 one for every recursive call."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_20", "There are ways to mitigate this \u2014 for example, some kinds of carefully-written recursion (in some programming languages, including C++) can avoid run-time stack growth as you recurse \u2014 but it's still a sign of potential trouble."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_21", "The time it will take you to build the degenerate tree will also be prohibitive."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_22", "If you start with an empty binary search tree and add keys to it in order, how long does it take to do it?"], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_23", "The first key you add will go directly to the root."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_24", "You could think of this as taking a single step: creating the node."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_25", "The second key you add will require you to look at the root node, then take one step to the right."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_26", "You could think of this as taking two steps."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_27", "Each subsequent key you add will require one more step than the one before it."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_28", "The total number of steps it would take to add n keys would be determined by the sum 1. + 2. + 3. + ... + n."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_29", "This sum, which we'll see several times throughout this course, is equal to n(n + 1) / 2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_30", "So, the total number of steps to build the entire tree would be \u0398(n2)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_31", "Overall, when n gets large, the tree would be hideously expensive to build, and then every subsequent search would be painful, as well."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_32", "So this, in general, is a situation we need to be sure to avoid, or else we should probably consider a data structure other than a binary search tree; the worst case is simply too much of a burden to bear if n might get large."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_33", "But if we can find a way to control the tree's shape more carefully, to force it to remain more balanced, we'll be fine."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_34", "The question, of course, is how to do it, and, as importantly, whether we can do it while keeping the cost low enough that it doesn't outweigh the benefit."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_35", "Aiming for perfection The best goal for us to shoot for would be to maintain perfection."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_36", "In other words, every time we insert a key into our binary search tree, it would ideally still be a perfect binary tree, in which case we'd know that the height of the tree would always be \u0398(log n), with a commensurate effect on performance."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_37", "However, when we consider this goal, a problem emerges almost immediately."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_38", "The following are all perfect binary trees, by definition: https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 2/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_39", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_40", "Spring 2022, Notes and Examples: AVL Trees The perfect binary trees pictured above have 1, 3, 7, and 15. nodes respectively, and are the only possible perfect shapes for binary trees with that number of nodes."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_41", "The problem, though, lies in the fact that there is no valid perfect binary tree with 2. nodes, or with 4, 5, 6, 8, 9, 10, 11, 12, 13, or 14. nodes."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_42", "So, generally, it's impossible for us to guarantee that a binary search tree will always be \"perfect,\" by our definition, because there's simply no way to represent most numbers of keys."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_43", "So, first thing's first: We'll need to relax our definition of \"perfection\" to accommodate every possible number of keys we might want to store."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_44", "Complete binary trees A somewhat more relaxed notion of \"perfection\" is something called a complete binary tree, which is defined as follows."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_45", "A complete binary tree of height h is a binary tree where: If h = 0, its left and right subtrees are empty."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_46", "If h > 0, one of two things is true: The left subtree is a perfect binary tree of height h \u2212 1. and the right subtree is a complete binary tree of height h \u2212 1."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_47", "The left subtree is a complete binary tree of height h \u2212 1. and the right subtree is a perfect binary tree of height h \u2212 2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_48", "That can be a bit of a mind-bending definition, but it actually leads to a conceptually simple result: On every level of a complete binary tree, every node that could possibly be present will be, except the last level might be missing nodes, but if it is missing nodes, the nodes that are there will be as far to the left as possible."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_49", "The following are all complete binary trees: Furthermore, these are the only possible complete binary trees with these numbers of nodes in them; any other arrangement of, say, 6. keys besides the one shown above would violate the definition."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_50", "We've seen that the height of a perfect binary tree is \u0398(log n)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_51", "It's not a stretch to see that the height a complete binary tree will be \u0398(log n), as well, and we'll accept that via our intuition for now and proceed."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_52", "All in all, a complete binary tree would be a great goal for us to attain: If we could keep the shape of our binary search trees complete, we would always have binary search trees with height \u0398(log n)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_53", "The cost of maintaining completeness The trouble, of course, is that we need an algorithm for maintaining completeness."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_54", "And before we go to the trouble of trying to figure one out, we should consider whether it's even worth our time."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_55", "What can we deduce about the cost of maintaining completeness, even if we haven't figured out an algorithm yet?"], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_56", "One example demonstrates a very big problem."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_57", "Suppose we had the binary search tree on the left \u2014 which is complete, by our definition \u2014 and we wanted to insert the key 1. into it."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_58", "If so, we would need an algorithm that would transform the tree on the left into the tree on the right. https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 3/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_59", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_60", "Spring 2022, Notes and Examples: AVL Trees The tree on the right is certainly complete, so this would be the outcome we'd want."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_61", "But consider what it would take to do it."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_62", "Every key in the tree had to move! So, no matter what algorithm we used, we would still have to move every key."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_63", "If there are n keys in the tree, that would take \u03a9(n) time \u2014 moving n keys takes at least linear time, even if you have the best possible algorithm for moving them; the work still has to get done."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_64", "So, in the worst case, maintaining completeness after a single insertion requires \u03a9(n) time."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_65", "Unfortunately, this is more time than we ought to be spending on maintaining balance."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_66", "This means we'll need to come up with a compromise; as is often the case when we learn or design algorithms, our willingness to tolerate an imperfect result that's still \"good enough\" for our uses will often lead to an algorithm that is much faster than one that achieves a perfect result."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_67", "So what would a \"good enough\" result be?"], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_68", "What is a \"good\" balance condition Our overall goal is for lookups, insertions, and removals from a binary search tree to require O(log n) time in every case, rather than letting them degrade to a worst-case behavior of O(n)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_69", "To do that, we need to decide on a balance condition, which is to say that we need to understand what shape is considered well- enough balanced for our purposes, even if not perfect."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_70", "A \"good\" balance condition has two properties: The height of a binary search tree meeting the condition is \u0398(log n)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_71", "It takes O(log n) time to re-balance the tree on insertions and removals."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_72", "In other words, it guarantees that the height of the tree is still logarithmic, which will give us logarithmic-time lookups, and the time spent re-balancing won't exceed the logarithmic time we would otherwise spend on an insertion or removal when the tree has logarithmic height."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_73", "The cost won't outweigh the benefit."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_74", "Coming up with a balance condition like this on our own is a tall task, but we can stand on the shoulders of the giants who came before us, with the definition above helping to guide us toward an understanding of whether we've found what we're looking for."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_75", "A compromise: AVL trees There are a few well-known approaches for maintaining binary search trees in a state of near-balance that meets our notion of a \"good\" balance condition."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_76", "One of them is called an AVL tree, which we'll explore here."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_77", "Others, which are outside the scope of this course, include red-black trees (which meet our definition of \"good\") and splay trees (which don't always meet our definition of \"good\", but do meet it on an amortized basis), but we'll stick with the one solution to the problem for now. https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 4/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_78", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_79", "Spring 2022, Notes and Examples: AVL Trees AVL trees AVL trees are what you might called \"nearly balanced\" binary search trees."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_80", "While they certainly aren't as perfectly-balanced as possible, they nonetheless achieve the goals we've decided on: maintaining logarithmic height at no more than logarithmic cost."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_81", "So, what makes a binary search tree \"nearly balanced\" enough to be considered an AVL tree?"], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_82", "The core concept is embodied by something called the AVL property."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_83", "We say that a node in a binary search tree has the AVL property if the heights of its left and right subtrees differ by no more than 1."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_84", "In other words, we tolerate a certain amount of imbalance \u2014 heights of subtrees can be slightly different, but no more than that \u2014 in hopes that we can more efficiently maintain it."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_85", "Since we're going to be comparing heights of subtrees, there's one piece of background we need to consider."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_86", "Recall that the height of a tree is the length of its longest path."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_87", "By definition, the height of a tree with just a root node (and empty subtrees) would then be zero."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_88", "But what about a tree that's totally empty?"], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_89", "To maintain a clear pattern, relative to other tree heights, we'll say that the height of an empty tree is -1."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_90", "This means that a node with, say, a childless left child and no right child would still be considered balanced."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_91", "This leads us, finally, to the definition of an AVL tree: An AVL tree is a binary search tree in which all nodes have the AVL property."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_92", "Below are a few binary trees, two of which are AVL and two of which are not."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_93", "The thing to keep in mind about AVL is that it's not a matter of squinting at a tree and deciding whether it \"looks\" balanced."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_94", "There's a precise definition, and the two trees above that don't meet that definition fail to meet it because they each have at least one node (marked in the diagrams by a dashed square) that doesn't have the AVL property."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_95", "AVL trees, by definition, are required to meet the balance condition after every operation; every time you insert or remove a key, every node in the tree should have the AVL property."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_96", "To meet that requirement, we need to restructure the tree periodically, essentially detecting and correcting imbalance whenever and wherever it happens."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_97", "To do that, we need to rearrange the tree in ways that improve its shape without losing the essential ordering property of a binary search tree: smaller keys toward the left, larger ones toward the right. https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 5/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_98", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_99", "Spring 2022, Notes and Examples: AVL Trees Rotations Re-balancing of AVL trees is achieved using what are called rotations, which, when used at the proper times, efficiently improve the shape of the tree by altering a handful of pointers."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_100", "There are a few kinds of rotations; we should first understand how they work, then focus our attention on when to use them."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_101", "The first kind of rotation is called an LL rotation, which takes the tree on the left and turns it into the tree on the right."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_102", "The circle with A and B written in them are each a single node containing a single key; the triangles with T , T , and T written in them are arbitrary subtrees, which may be empty or may contain any 1. 2. 3. number of nodes (but which are, themselves, binary search trees)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_103", "It's important to remember that both of these trees \u2014 before and after \u2014 are binary search trees; the rotation doesn't harm the ordering of the keys in nodes, because the subtrees T , T , and T maintain the appropriate positions relative to the keys A and B: 1. 2. 3."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_104", "All keys in T are smaller than A. 1."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_105", "All keys in T are larger than A and smaller than B. 2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_106", "All keys in T are larger than B. 3."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_107", "Performing this rotation would be a simple matter of adjusting a few pointers \u2014 notably, a constant number of pointers, no matter how many nodes are in the tree, which means that this rotation would run in \u0398(1) time: B's parent would now point to A where it used to point to B A's right child would now be B instead of the root of T 2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_108", "B's left child would now be the root of T instead of A 2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_109", "A second kind of rotation is an RR rotation, which makes a similar adjustment. https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 6/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_110", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_111", "Spring 2022, Notes and Examples: AVL Trees Note that an RR rotation is the mirror image of an LL rotation."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_112", "A third kind of rotation is an LR rotation, which makes an adjustment that's slightly more complicated."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_113", "An LR rotation requires five pointer updates instead of three, but this is still a constant number of changes and runs in \u0398(1) time."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_114", "Finally, there is an RL rotation, which is the mirror image of an LR rotation. https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 7/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_115", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_116", "Spring 2022, Notes and Examples: AVL Trees Once we understand the mechanics of how rotations work, we're one step closer to understanding AVL trees."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_117", "But these rotations aren't arbitrary; they're used specifically to correct imbalances that are detected after insertions or removals."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_118", "An insertion algorithm Inserting a key into an AVL tree starts out the same way as insertion into a binary search tree: Perform a lookup."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_119", "If you find the key already in the tree, you're done, because keys in a binary search tree must be unique."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_120", "When the lookup terminates without the key being found, add a new node in the appropriate leaf position where the lookup ended."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_121", "The problem is that adding the new node introduced the possibility of an imbalance."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_122", "For example, suppose we started with this AVL tree: and then we inserted the key 35. into it."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_123", "A binary search tree insertion would give us this as a result: https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 8/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_124", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_125", "Spring 2022, Notes and Examples: AVL Trees But this resulting tree is not an AVL tree, because the node containing the key 40. does not have the AVL property, because the difference in the heights of its subtrees is 2. (Its left subtree has height 1, its right subtree \u2014 which is empty \u2014 has height -1.) What can we do about it?"], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_126", "The answer lies in the following algorithm, which we perform after the normal insertion process: Work your way back up the tree from the position where you just added a node. (This could be quite simple if the insertion was done recursively.) Compare the heights of the left and right subtrees of each node."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_127", "When they differ by more than 1, choose a rotation that will fix the imbalance."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_128", "Note that comparing the heights of the left and right subtrees would be quite expensive if you didn't already know what they were."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_129", "The solution to this problem is for each node to store its height (i.e., the height of the subtree rooted there)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_130", "This can be cheaply updated after every insertion or removal as you unwind the recursion."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_131", "The rotation is chosen considering the two links along the path below the node where the imbalance is, heading back down toward where you inserted a node. (If you were wondering where the names LL, RR, LR, and RL come from, this is the answer to that mystery.) If the two links are both to the left, perform an LL rotation rooted where the imbalance is."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_132", "If the two links are both to the right, perform an RR rotation rooted where the imbalance is."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_133", "If the first link is to the left and the second is to the right, perform an LR rotation rooted where the imbalance is."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_134", "If the first link is to the right and the second is to the left, perform an RL rotation rooted where the imbalance is."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_135", "It can be shown that any one of these rotations \u2014 LL, RR, LR, or RL \u2014 will correct any imbalance brought on by inserting a key."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_136", "In this case, we'd perform an LR rotation \u2014 the first two links leading from 40. down toward 35. are a Left and a Right \u2014 rooted at 40, which would correct the imbalance, and the tree would be rearranged to look like this: https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 9/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_137", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_138", "Spring 2022, Notes and Examples: AVL Trees Compare this to the diagram describing an LR rotation: The node containing 40. is C The node containing 30. is A The node containing 35. is B The (empty) left subtree of the node containing 30. is T 1."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_139", "The (empty) left subtree of the node containing 35. is T 2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_140", "The (empty) right subtree of the node containing 35. is T 3."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_141", "The (empty) right subtree of the node containing 40. is T 4."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_142", "After the rotation, we see what we'd expect: The node B, which in our example contained 35, is now the root of the newly-rotated subtree The node A, which in our example contained 30, is now the left child of the root of the newly-rotated subtree The node C, which in our example contained 40, is now the right child of the root of the newly-rotated subtree The four subtrees T , T , T , and T were all empty, so they are still empty. 1. 2. 3. 4."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_143", "Note, too, that the tree is more balanced after the rotation than it was before."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_144", "This is no accident; a single rotation (LL, RR, LR, or RL) is all that's necessary to correct an imbalance introduced by the insertion algorithm."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_145", "A removal algorithm Removals are somewhat similar to insertions, in the sense that you would start with the usual binary search tree removal algorithm, then find and correct imbalances while the recursion unwinds."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_146", "The key difference is that removals can require more than one rotation to correct imbalances, but will still only require rotations on the path back up to the root from where the removal occurred \u2014 so, generally, O(log n) rotations."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_147", "Asymptotic analysis The key question here is What is the height of an AVL tree with n nodes?"], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_148", "If the answer is \u0398(log n), then we can be certain that lookups, insertions, and removals will take O(log n) time."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_149", "How can we be so sure? https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 10/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_150", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_151", "Spring 2022, Notes and Examples: AVL Trees Lookups would be O(log n) because they're the same as they are in a binary search tree that doesn't have the AVL property."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_152", "If the height of the tree is \u0398(log n), lookups will run in O(log n) time."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_153", "Insertions and removals, despite being slightly more complicated in an AVL tree, do their work by traversing a single path in the tree \u2014 potentially all the way down to a leaf position, then all the way back up."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_154", "If the length of the longest path \u2014 that's what the height of a tree is! \u2014 is \u0398(log n), then we know that none of these paths is longer than that, so insertions and removals will take O(log n) time."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_155", "So we're left with that key question."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_156", "What is the height of an AVL tree with n nodes? (If you're not curious, you can feel free to just assume this; if you want to know more, keep reading.) What is the height of an AVL tree with n nodes? (Optional) The answer revolves around noting how many nodes, at minimum, could be in a binary search tree of height n and still have it be an AVL tree."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_157", "It turns out AVL trees of height n \u2265 2. that have the minimum number of nodes in them all share a similar property: The AVL tree with height h \u2265 2. with the minimum number of nodes consists of a root node with two subtrees, one of which is an AVL tree with height h \u2212 1. with the minimum number of nodes, the other of which is an AVL tree with height h \u2212 2. with the minimum number of nodes."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_158", "Given that observation, we can write a recurrence that describes the number of nodes, at minimum, in an AVL tree of height h."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_159", "M(0) = 1."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_160", "When height is 0, minimum number of nodes is 1. (a root node with no children) M(1) = 2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_161", "When height is 1, minimum number of nodes is 2. (a root node with one child and not the other) M(h) = 1. + M(h - 1) + M(h - 2) While the repeated substitution technique we learned previously isn't a good way to try to solve this particular recurrence, we can prove something interesting quite easily."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_162", "We know for sure that AVL trees with larger heights have a bigger minimum number of nodes than AVL trees with smaller heights \u2014 that's fairly self-explanatory \u2014 which means that we can be sure that 1. + M(h \u2212 1) \u2265 M(h \u2212 2)."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_163", "Given that, we can conclude the following: M(h) \u2265 2M(h - 2) We can then use the repeated substitution technique to determine a lower bound for this recurrence: M(h) \u2265 2M(h - 2) \u2265 2(2M(h - 4)) \u2265 4M(h - 4) \u2265 4(2M(h - 6)) \u2265 8M(h - 6) ... \u2265 2jM(h - 2j) We could prove this by induction on j, but we'll accept it on faith let j = h/ 2. \u2265 2h/2M(h - h) \u2265 2h/2M(0) M(h) \u2265 2h/ 2. https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 11/ 12. 3/14/25, 12: 47."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_164", "PM ICS 46."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_165", "Spring 2022, Notes and Examples: AVL Trees So, we've shown that the minimum number of nodes that can be present in an AVL tree of height h is at least 2h/2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_166", "In reality, it's actually more than that, but this gives us something useful to work with; we can use this result to figure out what we're really interested in, which is the opposite: what is the height of an AVL tree with n nodes?"], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_167", "M(h) \u2265 2h/ 2. log M(h) \u2265 h/ 2. 2. 2. log M(h) \u2265 h 2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_168", "Finally, we see that, for AVL trees of height h with the minimum number of nodes, the height is no more than 2. log n, where n is the number of nodes in the tree. 2."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_169", "For AVL trees with more than the minimum number of nodes, the relationship between the number of nodes and the height is even better, though, for reasons we've seen previously, we know that the relationship between the number of nodes and the height of a binary tree can never be better than logarithmic."], ["ICS 46 Spring 2022, Notes and Examples_ AVL Trees_cleaned.txt_170", "So, ultimately, we see that the height of an AVL tree with n nodes is \u0398(log n). (In reality, it turns out that the bound is lower than 2. log n; it's something more akin to about 1. 44. log n, even for AVL trees with the minimum number of nodes, 2. 2. though the proof of that is more involved and doesn't change the asymptotic result.) https://ics.uci.edu/~thornton/ics46/Notes/AVLTrees/ 12/12"], ["03 - Moving Beyond the Relational Model_cleaned.txt_0", "DS 4300."], ["03 - Moving Beyond the Relational Model_cleaned.txt_1", "Moving Beyond the Relational Model Mark Fontenot, PhD Northeastern University Benefits of the Relational Model - (Mostly) Standard Data Model and Query Language - ACID Compliance (more on this in a second) - Atomicity, Consistency, Isolation, Durability - Works well will highly structured data - Can handle large amounts of data - Well understood, lots of tooling, lots of experience 2."], ["03 - Moving Beyond the Relational Model_cleaned.txt_2", "Relational Database Performance Many ways that a RDBMS increases efficiency: - indexing (the topic we focused on) - directly controlling storage - column oriented storage vs row oriented storage - query optimization - caching/prefetching - materialized views - precompiled stored procedures - data replication and partitioning 3."], ["03 - Moving Beyond the Relational Model_cleaned.txt_3", "Transaction Processing - Transaction - a sequence of one or more of the CRUD operations performed as a single, logical unit of work - Either the entire sequence succeeds (COMMIT) - OR the entire sequence fails (ROLLBACK or ABORT) - Help ensure - Data Integrity - Error Recovery - Concurrency Control - Reliable Data Storage - Simplified Error Handling 4."], ["03 - Moving Beyond the Relational Model_cleaned.txt_4", "ACID Properties - Atomicity - transaction is treated as an atomic unit - it is fully executed or no parts of it are executed - Consistency - a transaction takes a database from one consistent state to another consistent state - consistent state - all data meets integrity constraints 5."], ["03 - Moving Beyond the Relational Model_cleaned.txt_5", "ACID Properties - Isolation - Two transactions T and T are being executed at the same 1. 2. time but cannot affect each other - If both T and T are reading the data - no problem 1. 2. - If T is reading the same data that T may be writing, can 1. 2. result in: - Dirty Read - Non-repeatable Read - Phantom Reads 6."], ["03 - Moving Beyond the Relational Model_cleaned.txt_6", "Isolation: Dirty Read Dirty Read - a transaction T is able 1. to read a row that has been modified by another transaction T that hasn\u2019t 2. yet executed a COMMIT Figure from: https://www.mybluelinux.com/relational-databases-explained/ 7."], ["03 - Moving Beyond the Relational Model_cleaned.txt_7", "Isolation: Non-Repeatable Read Non-repeatable Read - two queries in a single transaction T execute a 1."], ["03 - Moving Beyond the Relational Model_cleaned.txt_8", "SELECT but get different values because another transaction T has 2. changed data and COMMITTED Figure from: https://www.mybluelinux.com/relational-databases-explained/ 8."], ["03 - Moving Beyond the Relational Model_cleaned.txt_9", "Isolation: Phantom Reads Phantom Reads - when a transaction T is running and 1. another transaction T adds or 2. deletes rows from the set T is using 1."], ["03 - Moving Beyond the Relational Model_cleaned.txt_10", "Figure from: https://www.mybluelinux.com/relational-databases-explained/ 9."], ["03 - Moving Beyond the Relational Model_cleaned.txt_11", "Example Transaction - Transfer $$ DELIMITER // CREATE PROCEDURE transfer( IN sender_id INT, IN receiver_id INT, IN amount DECIMAL(10,2) ) BEGIN DECLARE rollback_message VARCHAR(255) DEFAULT 'Transaction rolled back: Insufficient funds'; DECLARE commit_message VARCHAR(255) DEFAULT 'Transaction committed successfully'; -- Start the transaction START TRANSACTION; -- Attempt to debit money from account 1."], ["03 - Moving Beyond the Relational Model_cleaned.txt_12", "UPDATE accounts SET balance = balance - amount WHERE account_id = sender_id; -- Attempt to credit money to account 2."], ["03 - Moving Beyond the Relational Model_cleaned.txt_13", "UPDATE accounts SET balance = balance + amount WHERE account_id = receiver_id; -- Continued Next Slide 10."], ["03 - Moving Beyond the Relational Model_cleaned.txt_14", "Example Transaction - Transfer $$ -- Continued from previous slide -- Check if there are sufficient funds in account 1. -- Simulate a condition where there are insufficient funds IF (SELECT balance FROM accounts WHERE account_id = sender_id) < 0."], ["03 - Moving Beyond the Relational Model_cleaned.txt_15", "THEN -- Roll back the transaction if there are insufficient funds ROLLBACK; SIGNAL SQLSTATE '45000' -- 45000. is unhandled, user-defined error SET MESSAGE_TEXT = rollback_message; ELSE -- Log the transactions if there are sufficient funds INSERT INTO transactions (account_id, amount, transaction_type) VALUES (sender_id, -amount, 'WITHDRAWAL'); INSERT INTO transactions (account_id, amount, transaction_type) VALUES (receiver_id, amount, 'DEPOSIT'); -- Commit the transaction COMMIT; SELECT commit_message AS 'Result'; END IF; END // DELIMITER ; 11."], ["03 - Moving Beyond the Relational Model_cleaned.txt_16", "ACID Properties - Durability - Once a transaction is completed and committed successfully, its changes are permanent. - Even in the event of a system failure, committed transactions are preserved - For more info on Transactions, see: - Kleppmann Book Chapter 7. 12."], ["03 - Moving Beyond the Relational Model_cleaned.txt_17", "But \u2026 Relational Databases may not be the solution to all problems\u2026 - sometimes, schemas evolve over time - not all apps may need the full strength of ACID compliance - joins can be expensive - a lot of data is semi-structured or unstructured (JSON, XML, etc) - Horizontal scaling presents challenges - some apps need something more performant (real time, low latency systems) 13."], ["03 - Moving Beyond the Relational Model_cleaned.txt_18", "Scalability - Up or Out?"], ["03 - Moving Beyond the Relational Model_cleaned.txt_19", "Conventional Wisdom: Scale vertically (up, with bigger, more powerful systems) until the demands of high-availability make it necessary to scale out with some type of distributed computing model But why?"], ["03 - Moving Beyond the Relational Model_cleaned.txt_20", "Scaling up is easier - no need to really modify your architecture."], ["03 - Moving Beyond the Relational Model_cleaned.txt_21", "But there are practical and financial limits However: There are modern systems that make horizontal scaling less problematic. 14."], ["03 - Moving Beyond the Relational Model_cleaned.txt_22", "So what?"], ["03 - Moving Beyond the Relational Model_cleaned.txt_23", "Distributed Data when Scaling Out A distributed system is \u201ca collection of independent computers that appear to its users as one computer.\u201d -Andrew Tennenbaum Characteristics of Distributed Systems: - computers operate concurrently - computers fail independently - no shared global clock 15."], ["03 - Moving Beyond the Relational Model_cleaned.txt_24", "Distributed Storage - 2."], ["03 - Moving Beyond the Relational Model_cleaned.txt_25", "Directions Single Main Node 16."], ["03 - Moving Beyond the Relational Model_cleaned.txt_26", "Distributed Data Stores - Data is stored on > 1. node, typically replicated - i.e. each block of data is available on N nodes - Distributed databases can be relational or non-relational - MySQL and PostgreSQL support replication and sharding - CockroachDB - new player on the scene - Many NoSQL systems support one or both models - But remember: Network partitioning is inevitable! - network failures, system failures - Overall system needs to be Partition Tolerant - System can keep running even w/ network partition 17."], ["03 - Moving Beyond the Relational Model_cleaned.txt_27", "The CAP Theorem 18."], ["03 - Moving Beyond the Relational Model_cleaned.txt_28", "The CAP Theorem The CAP Theorem states that it is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees: - Consistency - Every read receives the most recent write or error thrown - Availability - Every request receives a (non-error) response - but no guarantee that the response contains the most recent write - Partition Tolerance - The system can continue to operate despite arbitrary network issues. 19."], ["03 - Moving Beyond the Relational Model_cleaned.txt_29", "CAP Theorem - Database View - Consistency*: Every user of the DB has an identical view of the data at any given instant - Availability: In the event of a failure, the database remains operational - Partition Tolerance: The database can maintain operations in the event of the network\u2019s failing between two segments of the distributed system * Note, the definition of Consistency in CAP is different from that of ACID."], ["03 - Moving Beyond the Relational Model_cleaned.txt_30", "Reference: https://alperenbayramoglu.com/posts/understanding-cap-theorem/ 20."], ["03 - Moving Beyond the Relational Model_cleaned.txt_31", "CAP Theorem - Database View - Consistency + Availability: System always responds with the latest data and every request gets a response, but may not be able to deal with network issues - Consistency + Partition Tolerance: If system responds with data from a distributed store, it is always the latest, else data request is dropped. - Availability + Partition Tolerance: System always sends are responds based on distributed store, but may not be the absolute latest data."], ["03 - Moving Beyond the Relational Model_cleaned.txt_32", "Reference: https://alperenbayramoglu.com/posts/understanding-cap-theorem/ 21."], ["03 - Moving Beyond the Relational Model_cleaned.txt_33", "CAP in Reality What it is really saying: - If you cannot limit the number of faults, requests can be directed to any server, and you insist on serving every request, then you cannot possibly be consistent."], ["03 - Moving Beyond the Relational Model_cleaned.txt_34", "But it is interpreted as: - You must always give up something: consistency, availability, or tolerance to failure. 22. ?? 23"], ["02 - Foundations_cleaned.txt_0", "DS 4300."], ["02 - Foundations_cleaned.txt_1", "Large Scale Information Storage and Retrieval Foundations Mark Fontenot, PhD Northeastern University Searching \u25cf Searching is the most common operation performed by a database system \u25cf In SQL, the SELECT statement is arguably the most versatile / complex. \u25cf Baseline for efficiency is Linear Search \u25cb Start at the beginning of a list and proceed element by element until: \u25a0 You find what you\u2019re looking for \u25a0 You get to the last element and haven\u2019t found it 2."], ["02 - Foundations_cleaned.txt_2", "Searching \u25cf Record - A collection of values for attributes of a single entity instance; a row of a table \u25cf Collection - a set of records of the same entity type; a table \u25cb Trivially, stored in some sequential order like a list \u25cf Search Key - A value for an attribute from the entity type \u25cb Could be >= 1. attribute 3."], ["02 - Foundations_cleaned.txt_3", "Lists of Records \u25cf If each record takes up x bytes of memory, then for n records, we need n*x bytes of memory. \u25cf Contiguously Allocated List \u25cb All n*x bytes are allocated as a single \u201cchunk\u201d of memory \u25cf Linked List \u25cb Each record needs x bytes + additional space for 1. or 2. memory addresses \u25cb Individual records are linked together in a type of chain using memory addresses 4."], ["02 - Foundations_cleaned.txt_4", "Contiguous vs Linked 6."], ["02 - Foundations_cleaned.txt_5", "Records Contiguously Allocated - Array front back Extra storage for a memory address 6."], ["02 - Foundations_cleaned.txt_6", "Records Linked by memory addresses - Linked List 5."], ["02 - Foundations_cleaned.txt_7", "Pros and Cons \u25cf Arrays are faster for random access, but slow for inserting anywhere but the end records: Insert after 2nd record records: 5. records had to be moved to make space \u25cf Linked Lists are faster for inserting anywhere in the list, but slower for random access Insert after 2nd record 6."], ["02 - Foundations_cleaned.txt_8", "Observations: - Arrays - fast for random access - slow for random insertions - Linked Lists - slow for random access - fast for random insertions 7."], ["02 - Foundations_cleaned.txt_9", "Binary Search \u25cf Input: array of values in sorted order, target value \u25cf Output: the location (index) of where target is located or some value indicating target was not found def binary_search(arr, target) left, right = 0, len(arr) - 1. left right while left <= right: A C G M P R Z target = A mid = (left + right) // 2. if arr[mid] == target: mid return mid Since target < arr[mid], we reset right to mid - 1. left right elif arr[mid] < target: left = mid + 1."], ["02 - Foundations_cleaned.txt_10", "A C G M P R Z target = A else: mid right = mid - 1. return - 1. 8."], ["02 - Foundations_cleaned.txt_11", "Time Complexity \u25cf Linear Search \u25cb Best case: target is found at the first element; only 1. comparison \u25cb Worst case: target is not in the array; n comparisons \u25cb Therefore, in the worst case, linear search is O(n) time complexity. \u25cf Binary Search \u25cb Best case: target is found at mid; 1. comparison (inside the loop) \u25cb Worst case: target is not in the array; log n comparisons 2. \u25cb Therefore, in the worst case, binary search is O(log n) time 2. complexity. 9."], ["02 - Foundations_cleaned.txt_12", "Back to Database Searching \u25cf Assume data is stored on disk by column id\u2019s value \u25cf Searching for a specific id = fast. \u25cf But what if we want to search for a specific specialVal? \u25cb Only option is linear scan of that column \u25cf Can\u2019t store data on disk sorted by both id and specialVal (at the same time) \u25cb data would have to be duplicated \u2192 space inefficient 10."], ["02 - Foundations_cleaned.txt_13", "Back to Database Searching \u25cf Assume data is stored on disk by column id\u2019s value \u25cf Searching for a specific id = fast. \u25cf But what if we want to search for a specific We need an external data structure specialVal? to support faster searching by \u25cb Only option is linear scan of that column specialVal than a linear scan. \u25cf Can\u2019t store data on disk sorted by both id and specialVal (at the same time) \u25cb data would have to be duplicated \u2192 space inefficient 11."], ["02 - Foundations_cleaned.txt_14", "What do we have in our arsenal? 1) An array of tuples (specialVal, rowNumber) sorted by specialVal a) We could use Binary Search to quickly locate a particular specialVal and find its corresponding row in the table b) But, every insert into the table would be like inserting into a sorted array - slow\u2026 2) A linked list of tuples (specialVal, rowNumber) sorted by specialVal a) searching for a specialVal would be slow - linear scan required b) But inserting into the table would theoretically be quick to also add to the list. 12."], ["02 - Foundations_cleaned.txt_15", "Something with Fast Insert and Fast Search? - Binary Search Tree - a binary tree where every node in the left subtree is less than its parent and every node in the right subtree is greater than its parent."], ["02 - Foundations_cleaned.txt_16", "Image from: https://courses.grainger.illinois.edu/cs225/sp2019/notes/bst/ 13."], ["02 - Foundations_cleaned.txt_17", "To the Board! 14"], ["09 - Introduction to Graph Data Model_cleaned.txt_0", "DS 4300."], ["09 - Introduction to Graph Data Model_cleaned.txt_1", "Introduction to the Graph Data Model Mark Fontenot, PhD Northeastern University Material referenced from Graph Algorithms - Practical Examples in Apache Spark and Neo4j by Needham and Hodler (O\u2019Reilly Press, 2019) What is a Graph Database - Data model based on the graph data structure - Composed of nodes and edges - edges connect nodes - each is uniquely identified - each can contain properties (e.g. name, occupation, etc) - supports queries based on graph-oriented operations - traversals - shortest path - lots of others 2."], ["09 - Introduction to Graph Data Model_cleaned.txt_2", "Where do Graphs Show up? - Social Networks - yes\u2026 things like Instagram, - but also\u2026 modeling social interactions in fields like psychology and sociology - The Web - it is just a big graph of \u201cpages\u201d (nodes) connected by hyperlinks (edges) - Chemical and biological data - systems biology, genetics, etc. - interaction relationships in chemistry 3."], ["09 - Introduction to Graph Data Model_cleaned.txt_3", "Basics of Graphs and Graph Theory 4."], ["09 - Introduction to Graph Data Model_cleaned.txt_4", "What is a graph?"], ["09 - Introduction to Graph Data Model_cleaned.txt_5", "Labeled Property Graph - Composed of a set of node (vertex) objects and relationship (edge) objects - Labels are used to mark a node as part of a group - Properties are attributes (think KV pairs) and can exist on nodes and relationships - Nodes with no associated relationships are OK."], ["09 - Introduction to Graph Data Model_cleaned.txt_6", "Edges not connected to nodes are not permitted. 5."], ["09 - Introduction to Graph Data Model_cleaned.txt_7", "Example 2."], ["09 - Introduction to Graph Data Model_cleaned.txt_8", "Labels: - person - car 4. relationship types: - Drives - Owns - Lives_with - Married_to Properties 6."], ["09 - Introduction to Graph Data Model_cleaned.txt_9", "Paths A path is an ordered sequence of nodes connected by edges in which no nodes or edges are repeated. 3. 1. 2."], ["09 - Introduction to Graph Data Model_cleaned.txt_10", "Ex: 1. \u2192 2. \u2192 6. \u2192 5."], ["09 - Introduction to Graph Data Model_cleaned.txt_11", "Not a path: 4. 6. 5. 1. \u2192 2. \u2192 6. \u2192 2. \u2192 3. 7."], ["09 - Introduction to Graph Data Model_cleaned.txt_12", "Flavors of Graphs Connected (vs."], ["09 - Introduction to Graph Data Model_cleaned.txt_13", "Disconnected) \u2013 there is a path between any two nodes in the graph Weighted (vs."], ["09 - Introduction to Graph Data Model_cleaned.txt_14", "Unweighted) \u2013 edge has a weight property (important for some algorithms) Directed (vs."], ["09 - Introduction to Graph Data Model_cleaned.txt_15", "Undirected) \u2013 relationships (edges) define a start and end node Acyclic (vs."], ["09 - Introduction to Graph Data Model_cleaned.txt_16", "Cyclic) \u2013 Graph contains no cycles 8."], ["09 - Introduction to Graph Data Model_cleaned.txt_17", "Connected vs."], ["09 - Introduction to Graph Data Model_cleaned.txt_18", "Disconnected 9."], ["09 - Introduction to Graph Data Model_cleaned.txt_19", "Weighted vs."], ["09 - Introduction to Graph Data Model_cleaned.txt_20", "Unweighted 10."], ["09 - Introduction to Graph Data Model_cleaned.txt_21", "Directed vs."], ["09 - Introduction to Graph Data Model_cleaned.txt_22", "Undirected 11."], ["09 - Introduction to Graph Data Model_cleaned.txt_23", "Cyclic vs Acyclic 12."], ["09 - Introduction to Graph Data Model_cleaned.txt_24", "Sparse vs."], ["09 - Introduction to Graph Data Model_cleaned.txt_25", "Dense 13."], ["09 - Introduction to Graph Data Model_cleaned.txt_26", "Trees 14."], ["09 - Introduction to Graph Data Model_cleaned.txt_27", "Types of Graph Algorithms - Pathfinding - Pathfinding - finding the shortest path between two nodes, if one exists, is probably the most common operation - \u201cshortest\u201d means fewest edges or lowest weight - Average Shortest Path can be used to monitor efficiency and resiliency of networks. - Minimum spanning tree, cycle detection, max/min flow\u2026 are other types of pathfinding 15."], ["09 - Introduction to Graph Data Model_cleaned.txt_28", "BFS vs DFS 16."], ["09 - Introduction to Graph Data Model_cleaned.txt_29", "Shortest Path 17."], ["09 - Introduction to Graph Data Model_cleaned.txt_30", "Types of Graph Algorithms - Centrality & Community Detection - Centrality - determining which nodes are \u201cmore important\u201d in a network compared to other nodes - EX: Social Network Influencers? - Community Detection - evaluate clustering or partitioning of nodes of a graph and tendency to strengthen or break apart 18."], ["09 - Introduction to Graph Data Model_cleaned.txt_31", "Centrality 19."], ["09 - Introduction to Graph Data Model_cleaned.txt_32", "Some Famous Graph Algorithms - Dijkstra\u2019s Algorithm - single-source shortest path algo for positively weighted graphs - A* Algorithm - Similar to Dijkstra\u2019s with added feature of using a heuristic to guide traversal - PageRank - measures the importance of each node within a graph based on the number of incoming relationships and the importance of the nodes from those incoming relationships 20."], ["09 - Introduction to Graph Data Model_cleaned.txt_33", "Neo4j - A Graph Database System that supports both transactional and analytical processing of graph-based data - Relatively new class of no-sql DBs - Considered schema optional (one can be imposed) - Supports various types of indexing - ACID compliant - Supports distributed computing - Similar: Microsoft CosmoDB, Amazon Neptune 21. ?? 22"], ["06 - Redis + Python_cleaned.txt_0", "DS 4300."], ["06 - Redis + Python_cleaned.txt_1", "Redis + Python Mark Fontenot, PhD Northeastern University Redis-py - Redis-py is the standard client for Python. - Maintained by the Redis Company itself - GitHub Repo: redis/redis-py - In your 4300."], ["06 - Redis + Python_cleaned.txt_2", "Conda Environment: pip install redis 2."], ["06 - Redis + Python_cleaned.txt_3", "Connecting to the Server import redis redis_client = redis.Redis(host=\u2019localhost\u2019, port=6379, db=2, decode_responses=True) - For your Docker deployment, host could be localhost or 127.0.0. 1. - Port is the port mapping given when you created the container (probably the default 6379) - db is the database 0- 15. you want to connect to - decode_responses \u2192 data comes back from server as bytes."], ["06 - Redis + Python_cleaned.txt_4", "Setting this true converter them (decodes) to strings. 3."], ["06 - Redis + Python_cleaned.txt_5", "Redis Command List - Full List > here < - Use Filter to get to command for the particular data structure you\u2019re targeting (list, hash, set, etc.) - Redis.py Documentation > here < - The next slides are not meant to be an exhaustive list of commands, only some highlights."], ["06 - Redis + Python_cleaned.txt_6", "Check the documentation for a complete list. 4."], ["06 - Redis + Python_cleaned.txt_7", "String Commands # r represents the Redis client object r.set(\u2018clickCount:/abc\u2019, 0) val = r.get(\u2018clickCount:/abc\u2019) r.incr(\u2018clickCount:/abc\u2019) ret_val = r.get(\u2018clickCount:/abc\u2019) print(f\u2019click count = {ret_val}\u2019) 5."], ["06 - Redis + Python_cleaned.txt_8", "String Commands - 2. # r represents the Redis client object redis_client.mset({'key1': 'val1', 'key2': 'val2', 'key3': 'val3'}) print(redis_client.mget('key1', 'key2', 'key3')) # returns as list [\u2018val1\u2019, \u2018val2\u2019, \u2018val3\u2019] 6."], ["06 - Redis + Python_cleaned.txt_9", "String Commands - 3. - set(), mset(), setex(), msetnx(), setnx() - get(), mget(), getex(), getdel() - incr(), decr(), incrby(), decrby() - strlen(), append() 7."], ["06 - Redis + Python_cleaned.txt_10", "List Commands - 1. # create list: key = \u2018names\u2019 # values = [\u2018mark\u2019, \u2018sam\u2019, \u2018nick\u2019] redis_client.rpush('names', 'mark', 'sam', 'nick') # prints [\u2018mark\u2019, \u2018sam\u2019, \u2018nick\u2019] print(redis_client.lrange('names', 0, -1)) 8."], ["06 - Redis + Python_cleaned.txt_11", "List Commands - 2. - lpush(), lpop(), lset(), lrem() - rpush(), rpop() - lrange(), llen(), lpos() - Other commands include moving elements between lists, popping from multiple lists at the same time, etc. 9."], ["06 - Redis + Python_cleaned.txt_12", "Hash Commands - 1. redis_client.hset('user-session:123', mapping={'first': 'Sam', 'last': 'Uelle', 'company': 'Redis', 'age': 30. }) # prints: #{'name': 'Sam', 'surname': 'Uelle', 'company': 'Redis', 'age': '30'} print(redis_client.hgetall('user-session:123')) 10."], ["06 - Redis + Python_cleaned.txt_13", "Hash Commands - 2. - hset(), hget(), hgetall() - hkeys() - hdel(), hexists(), hlen(), hstrlen() 11."], ["06 - Redis + Python_cleaned.txt_14", "Redis Pipelines - Helps avoid multiple related calls to the server \u2192 less network overhead r = redis.Redis(decode_responses=True) pipe = r.pipeline() for i in range(5): pipe.set(f\"seat:{i}\", f\"#{i}\") set_5_result = pipe.execute() print(set_5_result) # >>> [True, True, True, True, True] pipe = r.pipeline() # \"Chain\" pipeline commands together. get_3_result = pipe.get(\"seat:0\").get(\"seat:3\").get(\"seat:4\").execute() print(get_3_result) # >>> ['#0', '#3', '#4'] 12."], ["06 - Redis + Python_cleaned.txt_15", "Redis in Context 13."], ["06 - Redis + Python_cleaned.txt_16", "Redis in ML - Simplified Example Source: https://www.featureform.com/post/feature-stores-explained-the-three-common-architectures 14."], ["06 - Redis + Python_cleaned.txt_17", "Redis in DS/ML Source: https://madewithml.com/courses/mlops/feature-store/ 15"], ["08 - PyMongo_cleaned.txt_0", "DS 4300."], ["08 - PyMongo_cleaned.txt_1", "MongoDB + PyMongo Mark Fontenot, PhD Northeastern University PyMongo \u25cf PyMongo is a Python library for interfacing with MongoDB instances from pymongo import MongoClient client = MongoClient( \u2018mongodb://user_name:pw@localhost:27017\u2019 ) 2."], ["08 - PyMongo_cleaned.txt_2", "Getting a Database and Collection from pymongo import MongoClient client = MongoClient( \u2018mongodb://user_name:pw@localhost:27017\u2019 ) db = client[\u2018ds4300\u2019] # or client.ds 4300. collection = db[\u2018myCollection\u2019] #or db.myCollection 3."], ["08 - PyMongo_cleaned.txt_3", "Inserting a Single Document db = client[\u2018ds4300\u2019] collection = db[\u2018myCollection\u2019] post = { \u201cauthor\u201d: \u201cMark\u201d, \u201ctext\u201d: \u201cMongoDB is Cool!\u201d, \u201ctags\u201d: [\u201cmongodb\u201d, \u201cpython\u201d] } post_id = collection.insert_one(post).inserted_id print(post_id) 4."], ["08 - PyMongo_cleaned.txt_4", "Find all Movies from 2000. from bson.json_util import dumps # Find all movies released in 2000. movies_ 2000. = db.movies.find({\"year\": 2000}) # Print results print(dumps(movies_2000, indent = 2)) 5."], ["08 - PyMongo_cleaned.txt_5", "Jupyter Time - Activate your DS 4300. conda or venv python environment - Install pymongo with pip install pymongo - Install Jupyter Lab in you python environment - pip install jupyterlab - Download and unzip > this < zip file - contains 2."], ["08 - PyMongo_cleaned.txt_6", "Jupyter Notebooks - In terminal, navigate to the folder where you unzipped the files, and run jupyter lab 6. ?? 7"], ["07 - Document DBs and Mongo_cleaned.txt_0", "DS 4300."], ["07 - Document DBs and Mongo_cleaned.txt_1", "Document Databases & MongoDB Mark Fontenot, PhD Northeastern University Some material used with permission from Dr."], ["07 - Document DBs and Mongo_cleaned.txt_2", "Rachlin, with thanks! Document Database A Document Database is a non-relational database that stores data as structured documents, usually in JSON."], ["07 - Document DBs and Mongo_cleaned.txt_3", "They are designed to be simple, flexible, and scalable. 2."], ["07 - Document DBs and Mongo_cleaned.txt_4", "What is JSON? \u25cf JSON (JavaScript Object Notation) \u25cb a lightweight data-interchange format \u25cb It is easy for humans to read and write. \u25cb It is easy for machines to parse and generate. \u25cf JSON is built on two structures: \u25cb A collection of name/value pairs."], ["07 - Document DBs and Mongo_cleaned.txt_5", "In various languages, this is operationalized as an object, record, struct, dictionary, hash table, keyed list, or associative array. \u25cb An ordered list of values."], ["07 - Document DBs and Mongo_cleaned.txt_6", "In most languages, this is operationalized as an array, vector, list, or sequence. \u25cf These are two universal data structures supported by virtually all modern programming languages \u25cb Thus, JSON makes a great data interchange format. 3."], ["07 - Document DBs and Mongo_cleaned.txt_7", "JSON Syntax https://www.json.org/json-en.html 4."], ["07 - Document DBs and Mongo_cleaned.txt_8", "Binary JSON?"], ["07 - Document DBs and Mongo_cleaned.txt_9", "BSON - BSON \u2192 Binary JSON - binary-encoded serialization of a JSON-like document structure - supports extended types not part of basic JSON (e.g."], ["07 - Document DBs and Mongo_cleaned.txt_10", "Date, BinaryData, etc) - Lightweight - keep space overhead to a minimum - Traversable - designed to be easily traversed, which is vitally important to a document DB - Efficient - encoding and decoding must be efficient - Supported by many modern programming languages 5."], ["07 - Document DBs and Mongo_cleaned.txt_11", "XML (eXtensible Markup Language) \u25cf Precursor to JSON as data exchange format \u25cf XML + CSS \u2192 web pages that separated content and formatting \u25cf Structurally similar to HTML, but tag set is extensible 6."], ["07 - Document DBs and Mongo_cleaned.txt_12", "XML-Related Tools/Technologies - Xpath - a syntax for retrieving specific elements from an XML doc - Xquery - a query language for interrogating XML documents; the SQL of XML - DTD - Document Type Definition - a language for describing the allowed structure of an XML document - XSLT - eXtensible Stylesheet Language Transformation - tool to transform XML into other formats, including non-XML formats such as HTML. 7."], ["07 - Document DBs and Mongo_cleaned.txt_13", "Why Document Databases? - Document databases address the impedance mismatch problem between object persistence in OO systems and how relational DBs structure data. - OO Programming \u2192 Inheritance and Composition of types. - How do we save a complex object to a relational database?"], ["07 - Document DBs and Mongo_cleaned.txt_14", "We basically have to deconstruct it. - The structure of a document is self-describing. - They are well-aligned with apps that use JSON/XML as a transport layer 8."], ["07 - Document DBs and Mongo_cleaned.txt_15", "MongoDB 9."], ["07 - Document DBs and Mongo_cleaned.txt_16", "MongoDB - Started in 2007. after Doubleclick was acquired by Google, and 3. of its veterans realized the limitations of relational databases for serving > 400, 000. ads per second - MongoDB was short for Humongous Database - MongoDB Atlas released in 2016. \u2192 documentdb as a service https://www.mongodb.com/company/our-story 10."], ["07 - Document DBs and Mongo_cleaned.txt_17", "MongoDB Structure Database Collection A Collection B Collection C Document 1."], ["07 - Document DBs and Mongo_cleaned.txt_18", "Document 1."], ["07 - Document DBs and Mongo_cleaned.txt_19", "Document 1."], ["07 - Document DBs and Mongo_cleaned.txt_20", "Document 2."], ["07 - Document DBs and Mongo_cleaned.txt_21", "Document 2."], ["07 - Document DBs and Mongo_cleaned.txt_22", "Document 2."], ["07 - Document DBs and Mongo_cleaned.txt_23", "Document 3."], ["07 - Document DBs and Mongo_cleaned.txt_24", "Document 3."], ["07 - Document DBs and Mongo_cleaned.txt_25", "Document 3. 11."], ["07 - Document DBs and Mongo_cleaned.txt_26", "MongoDB Documents - No predefined schema for documents is needed - Every document in a collection could have different data/schema 12."], ["07 - Document DBs and Mongo_cleaned.txt_27", "Relational vs Mongo/Document DB RDBMS MongoDB Database Database Table/View Collection Row Document Column Field Index Index Join Embedded Document Foreign Key Reference 13."], ["07 - Document DBs and Mongo_cleaned.txt_28", "MongoDB Features - Rich Query Support - robust support for all CRUD ops - Indexing - supports primary and secondary indices on document fields - Replication - supports replica sets with automatic failover - Load balancing built in 14."], ["07 - Document DBs and Mongo_cleaned.txt_29", "MongoDB Versions \u25cf MongoDB Atlas \u25cb Fully managed MongoDB service in the cloud (DBaaS) \u25cf MongoDB Enterprise \u25cb Subscription-based, self-managed version of MongoDB \u25cf MongoDB Community \u25cb source-available, free-to-use, self-managed 15."], ["07 - Document DBs and Mongo_cleaned.txt_30", "Interacting with MongoDB \u25cf mongosh \u2192 MongoDB Shell \u25cb CLI tool for interacting with a MongoDB instance \u25cf MongoDB Compass \u25cb free, open-source GUI to work with a MongoDB database \u25cf DataGrip and other 3rd Party Tools \u25cf Every major language has a library to interface with MongoDB \u25cb PyMongo (Python), Mongoose (JavaScript/node), \u2026 16."], ["07 - Document DBs and Mongo_cleaned.txt_31", "Mongodb Community Edition in Docker - Create a container - Map host:container port 27017."], ["07 - Document DBs and Mongo_cleaned.txt_32", "E - Give initial username and D password for superuser 17."], ["07 - Document DBs and Mongo_cleaned.txt_33", "MongoDB Compass - GUI Tool for interacting with MongoDB instance - Download and install from > here <. 18."], ["07 - Document DBs and Mongo_cleaned.txt_34", "Load MFlix Sample Data Set - In Compass, create a new Database named mflix - Download mflix sample dataset and unzip it - Import JSON files for users, theaters, movies, and comments into new collections in the mflix database 19."], ["07 - Document DBs and Mongo_cleaned.txt_35", "Creating a Database and Collection To Create a new DB: mflix users To Create a new Collection: 20. mongosh - Mongo Shell - find(...) is like SELECT collection.find({ ____ }, { ____ }) filters projections 21. mongosh - find() - SELECT * FROM users; use mflix db.users.find() 22. - SELECT * mongosh - find() FROM users WHERE name = \u201cDavos Seaworth\u201d; filter db.users.find({\"name\": \"Davos Seaworth\"}) 23. mongosh - find() - SELECT * FROM movies WHERE rated in (\"PG\", \"PG-13\") db.movies.find({rated: {$in:[ \"PG\", \"PG-13\" ]}}) 24. mongosh - find() - Return movies which were released in Mexico and have an IMDB rating of at least 7. db.movies.find( { \"countries\": \"Mexico\", \"imdb.rating\": { $gte: 7. } } ) 25. mongosh - find() - Return movies from the movies collection which were released in 2010. and either won at least 5. awards or have a genre of Drama db.movies.find( { \u201cyear\u201d: 2010, $or: [ { \"awards.wins\": { $gte: 5. } }, { \u201cgenres\u201d: \"Drama\" } ] }) 26."], ["07 - Document DBs and Mongo_cleaned.txt_36", "Comparison Operators 27. mongosh - countDocuments() - How many movies from the movies collection were released in 2010. and either won at least 5. awards or have a genre of Drama db.movies.countDocuments( { \u201cyear\u201d: 2010, $or: [ { \"awards.wins\": { $gte: 5. } }, { \u201cgenres\u201d: \"Drama\" } ] }) 28. mongosh - project - Return the names of all movies from the movies collection that were released in 2010. and either won at least 5. awards or have a genre of Drama db.movies.countDocuments( { \u201cyear\u201d: 2010, $or: [ { \"awards.wins\": { $gte: 5. } }, { \u201cgenres\u201d: \"Drama\" } ] }, {\u201cname\u201d: 1, \u201c_id\u201d: 0} ) 1. = return; 0. = don\u2019t return 29."], ["07 - Document DBs and Mongo_cleaned.txt_37", "PyMongo 30."], ["07 - Document DBs and Mongo_cleaned.txt_38", "PyMongo \u25cf PyMongo is a Python library for interfacing with MongoDB instances from pymongo import MongoClient client = MongoClient( \u2018mongodb://user_name:pw@localhost:27017\u2019 ) 31."], ["07 - Document DBs and Mongo_cleaned.txt_39", "Getting a Database and Collection from pymongo import MongoClient client = MongoClient( \u2018mongodb://user_name:pw@localhost:27017\u2019 ) db = client[\u2018ds4300\u2019] collection = db[\u2018myCollection\u2019] 32."], ["07 - Document DBs and Mongo_cleaned.txt_40", "Inserting a Single Document db = client[\u2018ds4300\u2019] collection = db[\u2018myCollection\u2019] post = { \u201cauthor\u201d: \u201cMark\u201d, \u201ctext\u201d: \u201cMongoDB is Cool!\u201d, \u201ctags\u201d: [\u201cmongodb\u201d, \u201cpython\u201d] } post_id = collection.insert_one(post).inserted_id print(post_id) 33."], ["07 - Document DBs and Mongo_cleaned.txt_41", "Count Documents in Collection - SELECT count(*) FROM collection demodb.collection.count_documents({}) 34. ?? 35"], ["04 - Data Replication_cleaned.txt_0", "DS 4300."], ["04 - Data Replication_cleaned.txt_1", "Replicating Data Mark Fontenot, PhD Northeastern University Some material used with permission from Dr."], ["04 - Data Replication_cleaned.txt_2", "Rachlin, with thanks! Distributing Data - Benefits - Scalability / High throughput: Data volume or Read/Write load grows beyond the capacity of a single machine - Fault Tolerance / High Availability: Your application needs to continue working even if one or more machines goes down. - Latency: When you have users in different parts of the world you want to give them fast performance too 2."], ["04 - Data Replication_cleaned.txt_3", "Distributed Data - Challenges - Consistency: Updates must be propagated across the network. - Application Complexity: Responsibility for reading and writing data in a distributed environment often falls to the application. 3."], ["04 - Data Replication_cleaned.txt_4", "Vertical Scaling - Shared Memory Architectures - Geographically Centralized server - Some fault tolerance (via hot-swappable components) 4."], ["04 - Data Replication_cleaned.txt_5", "Vertical Scaling - Shared Disk Architectures - Machines are connected via a fast network - Contention and the overhead of locking limit scalability (high-write volumes) \u2026 BUT ok for Data Warehouse applications (high read volumes) 5. 4202. tcO - gnicirP 2CE SWA > $78,000/month 6. https://aws.amazon.com/ec2/pricing/on-demand/ Horizontal Scaling - Shared Nothing Architectures \u25cf Each node has its own CPU, memory, and disk \u25cf Coordination via application layer using conventional network \u25cf Geographically distributed \u25cf Commodity hardware 7."], ["04 - Data Replication_cleaned.txt_6", "Data - Replication vs Partitioning Replicates have Partitions have a same data as Main subset of the data 8."], ["04 - Data Replication_cleaned.txt_7", "Replication 9."], ["04 - Data Replication_cleaned.txt_8", "Common Strategies for Replication - Single leader model - Multiple leader model - Leaderless model Distributed databases usually adopt one of these strategies. 10."], ["04 - Data Replication_cleaned.txt_9", "Leader-Based Replication - All writes from clients go to the leader - Leader sends replication info to the followers - Followers process the instructions from the leader - Clients can read from either the leader or followers 11."], ["04 - Data Replication_cleaned.txt_10", "Leader-Based Replication This write could NOT be sent to one of the followers\u2026 only the leader. 12."], ["04 - Data Replication_cleaned.txt_11", "Leader-Based Replication - Very Common Strategy Relational: \u25cf MySQL, \u25cf Oracle, \u25cf SQL Server, \u25cf PostgreSQL NoSQL: \u25cf MongoDB, \u25cf RethinkDB (realtime web apps), \u25cf Espresso (LinkedIn) Messaging Brokers: Kafka, RabbitMQ 13."], ["04 - Data Replication_cleaned.txt_12", "How Is Replication Info Transmitted to Followers?"], ["04 - Data Replication_cleaned.txt_13", "Replication Method Description Statement-based Send INSERT, UPDATE, DELETEs to replica."], ["04 - Data Replication_cleaned.txt_14", "Simple but error-prone due to non-deterministic functions like now(), trigger side-effects, and difficulty in handling concurrent transactions."], ["04 - Data Replication_cleaned.txt_15", "Write-ahead Log (WAL) A byte-level specific log of every change to the database."], ["04 - Data Replication_cleaned.txt_16", "Leader and all followers must implement the same storage engine and makes upgrades difficult."], ["04 - Data Replication_cleaned.txt_17", "Logical (row-based) Log For relational DBs: Inserted rows, modified rows (before and after), deleted rows."], ["04 - Data Replication_cleaned.txt_18", "A transaction log will identify all the rows that changed in each transaction and how they changed."], ["04 - Data Replication_cleaned.txt_19", "Logical logs are decoupled from the storage engine and easier to parse."], ["04 - Data Replication_cleaned.txt_20", "Trigger-based Changes are logged to a separate table whenever a trigger fires in response to an insert, update, or delete."], ["04 - Data Replication_cleaned.txt_21", "Flexible because you can have application specific replication, but also more error prone. 14."], ["04 - Data Replication_cleaned.txt_22", "Synchronous vs Asynchronous Replication Synchronous: Leader waits for a response from the follower Asynchronous: Leader doesn\u2019t wait for confirmation."], ["04 - Data Replication_cleaned.txt_23", "Synchronous: Asynchronous: 15."], ["04 - Data Replication_cleaned.txt_24", "What Happens When the Leader Fails?"], ["04 - Data Replication_cleaned.txt_25", "Challenges: How do we pick a new Leader Node? \u25cf Consensus strategy \u2013 perhaps based on who has the most updates? \u25cf Use a controller node to appoint new leader?"], ["04 - Data Replication_cleaned.txt_26", "AND\u2026 how do we configure clients to start writing to the new leader? 16."], ["04 - Data Replication_cleaned.txt_27", "What Happens When the Leader Fails?"], ["04 - Data Replication_cleaned.txt_28", "More Challenges: \u25cf If asynchronous replication is used, new leader may not have all the writes How do we recover the lost writes?"], ["04 - Data Replication_cleaned.txt_29", "Or do we simply discard? \u25cf After (if?) the old leader recovers, how do we avoid having multiple leaders receiving conflicting data? (Split brain: no way to resolve conflicting requests. \u25cf Leader failure detection."], ["04 - Data Replication_cleaned.txt_30", "Optimal timeout is tricky. 17."], ["04 - Data Replication_cleaned.txt_31", "Replication Lag Replication Lag refers to the time it takes for writes on the leader to be reflected on all of the followers. \u25cf Synchronous replication: Replication lag causes writes to be slower and the system to be more brittle as num followers increases. \u25cf Asynchronous replication: We maintain availability but at the cost of delayed or eventual consistency."], ["04 - Data Replication_cleaned.txt_32", "This delay is called the inconsistency window. 18."], ["04 - Data Replication_cleaned.txt_33", "Read-after-Write Consistency Scenario - you\u2019re adding a comment to a Reddit post\u2026 after you click Submit and are back at the main post, your comment should show up for you. - Less important for other users to see your comment as immediately. 19."], ["04 - Data Replication_cleaned.txt_34", "Implementing Read-After-Write Consistency Method 1: Modifiable data (from the client\u2019s perspective) is always read from the leader. 20."], ["04 - Data Replication_cleaned.txt_35", "Implementing Read-After-Write Consistency Method 2: Dynamically switch to reading from leader for \u201crecently updated\u201d data. - For example, have a policy that all requests within one minute of last update come from leader. 21."], ["04 - Data Replication_cleaned.txt_36", "But\u2026 This Can Create Its Own Challenges We created followers so they would be proximal to users."], ["04 - Data Replication_cleaned.txt_37", "BUT\u2026 now we have to route requests to distant leaders when reading modifiable data?? :( 22."], ["04 - Data Replication_cleaned.txt_38", "Monotonic Read Consistency Monotonic read anomalies: occur when a user reads values out of order from multiple followers."], ["04 - Data Replication_cleaned.txt_39", "Monotonic read consistency: ensures that when a user makes multiple reads, they will not read older data after previously reading newer data. 23."], ["04 - Data Replication_cleaned.txt_40", "Consistent Prefix Reads Reading data out of order can occur if different partitions How far into the future can you see, Ms."], ["04 - Data Replication_cleaned.txt_41", "B? replicate data at different A rates."], ["04 - Data Replication_cleaned.txt_42", "There is no global write consistency."], ["04 - Data Replication_cleaned.txt_43", "Consistent Prefix Read About 10. seconds usually, Mr A."], ["04 - Data Replication_cleaned.txt_44", "B Guarantee - ensures that if a sequence of writes happens in a certain order, anyone reading those writes will see them appear in the same order. 24. ?? 25"], ["04-B+Tree Walkthrough_cleaned.txt_0", "DS 4300."], ["04-B+Tree Walkthrough_cleaned.txt_1", "Large Scale Information Storage and Retrieval B+ Tree Walkthrough Mark Fontenot, PhD Northeastern University Insert: 42, 21, 63, 89."], ["04-B+Tree Walkthrough_cleaned.txt_2", "B+ Tree : m = 4. \u25cf Initially, the first node is a leaf node AND root node. \u25cf 21, 42, \u2026 represent keys of some set of K:V pairs \u25cf Leaf nodes store keys and data, although data not shown \u25cf Inserting another key will cause the node to split. 2."], ["04-B+Tree Walkthrough_cleaned.txt_3", "Insert: 35."], ["04-B+Tree Walkthrough_cleaned.txt_4", "B+ Tree : m = 4. \u25cf Leaf node needs to split to accommodate 35."], ["04-B+Tree Walkthrough_cleaned.txt_5", "New leaf node allocated to the right of existing node \u25cf 5/ 2. values stay in original node; remaining values moved to new node \u25cf Smallest value from new leaf node (42) is copied up to the parent, which needs to be created in this case."], ["04-B+Tree Walkthrough_cleaned.txt_6", "It will be an internal node. 3."], ["04-B+Tree Walkthrough_cleaned.txt_7", "B+ Tree : m = 4."], ["04-B+Tree Walkthrough_cleaned.txt_8", "Insert: 10, 27, 96. \u25cf The insert process starts at the root node."], ["04-B+Tree Walkthrough_cleaned.txt_9", "The keys of the root node are searched to find out which child node we need to descend to. \u25cb EX: 10."], ["04-B+Tree Walkthrough_cleaned.txt_10", "Since 10. < 42, we follow the pointer to the left of 42. \u25cf Note - none of these new values cause a node to split 4."], ["04-B+Tree Walkthrough_cleaned.txt_11", "B+ Tree : m = 4."], ["04-B+Tree Walkthrough_cleaned.txt_12", "Insert: 30. \u25cf Starting at root, we descend to the left-most child (we\u2019ll call curr). \u25cb curr is a leaf node."], ["04-B+Tree Walkthrough_cleaned.txt_13", "Thus, we insert 30. into curr. \u25cb BUT curr is full."], ["04-B+Tree Walkthrough_cleaned.txt_14", "So we have to split. \u25cb Create a new node to the right of curr, temporarily called newNode. \u25cb Insert newNode into the doubly linked list of leaf nodes. 5."], ["04-B+Tree Walkthrough_cleaned.txt_15", "B+ Tree : m = 4."], ["04-B+Tree Walkthrough_cleaned.txt_16", "Insert: 30. cont\u2019d. \u25cf re-distribute the keys \u25cf copy the smallest key ( 27. in this case) from newNode to parent; rearrange keys and pointers in parent node. \u25cf Parent of newNode is also root."], ["04-B+Tree Walkthrough_cleaned.txt_17", "So, nothing else to do. 6."], ["04-B+Tree Walkthrough_cleaned.txt_18", "B+ Tree : m = 4."], ["04-B+Tree Walkthrough_cleaned.txt_19", "Fast forward to this state of the tree\u2026 \u25cf Observation: The root node is full. \u25cb The next insertion that splits a leaf will cause the root to split, and thus the tree will get 1. level deeper. 7."], ["04-B+Tree Walkthrough_cleaned.txt_20", "Insert 37."], ["04-B+Tree Walkthrough_cleaned.txt_21", "Step 1."], ["04-B+Tree Walkthrough_cleaned.txt_22", "B+ Tree : m = 4. 8."], ["04-B+Tree Walkthrough_cleaned.txt_23", "Insert 37."], ["04-B+Tree Walkthrough_cleaned.txt_24", "Step 2."], ["04-B+Tree Walkthrough_cleaned.txt_25", "B+ Tree : m = 4. \u25cf When splitting an internal node, we move the middle element to the parent (instead of copying it). \u25cf In this particular tree, that means we have to create a new internal node which is also now the root. 9"], ["10 - Neo4j_cleaned.txt_0", "DS 4300."], ["10 - Neo4j_cleaned.txt_1", "Neo4j Mark Fontenot, PhD Northeastern University Material referenced from Graph Algorithms - Practical Examples in Apache Spark and Neo4j by Needham and Hodler (O\u2019Reilly Press, 2019) Neo4j - A Graph Database System that supports both transactional and analytical processing of graph-based data - Relatively new class of no-sql DBs - Considered schema optional (one can be imposed) - Supports various types of indexing - ACID compliant - Supports distributed computing - Similar: Microsoft CosmoDB, Amazon Neptune 2."], ["10 - Neo4j_cleaned.txt_2", "Neo4j - Query Language and Plugins - Cypher - Neo4j\u2019s graph query language created in 2011. - Goal: SQL-equivalent language for graph databases - Provides a visual way of matching patterns and relationships (nodes)-[:CONNECT_TO]->(otherNodes) - APOC Plugin - Awesome Procedures on Cypher - Add-on library that provides hundreds of procedures and functions - Graph Data Science Plugin - provides efficient implementations of common graph algorithms (like the ones we talked about yesterday) 3."], ["10 - Neo4j_cleaned.txt_3", "Neo4j in Docker Compose 4."], ["10 - Neo4j_cleaned.txt_4", "Docker Compose \u25cf Supports multi-container management. \u25cf Set-up is declarative - using YAML docker-compose.yaml file \u25cb services \u25cb volumes \u25cb networks, etc. \u25cf 1. command can be used to start, stop, or scale a number of services at one time. \u25cf Provides a consistent method for producing an identical environment (no more \u201cwell\u2026 it works on my machine!) \u25cf Interaction is mostly via command line 5. docker-compose.yaml services: Never put \u201csecrets\u201d in a neo4j: container_name: neo4j docker compose file."], ["10 - Neo4j_cleaned.txt_5", "Use .env image: neo4j:latest ports: files. - 7474: 7474. - 7687: 7687. environment: - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD} - NEO4J_apoc_export_file_enabled=true - NEO4J_apoc_import_file_enabled=true - NEO4J_apoc_import_file_use__neo4j__config=true - NEO4J_PLUGINS=[\"apoc\", \"graph-data-science\"] volumes: - ./neo4j_db/data:/data - ./neo4j_db/logs:/logs - ./neo4j_db/import:/var/lib/neo4j/import - ./neo4j_db/plugins:/plugins 6. .env Files - .env files - stores a collection of environment variables - good way to keep environment variables for different platforms separate - .env.local .env file - .env.dev - .env.prod NEO4J_PASSWORD=abc123!!! 7."], ["10 - Neo4j_cleaned.txt_6", "Docker Compose Commands \u25cf To test if you have Docker CLI properly installed, run: docker --version \u25cf Major Docker Commands \u25cb docker compose up \u25cb docker compose up -d \u25cb docker compose down \u25cb docker compose start \u25cb docker compose stop \u25cb docker compose build \u25cb docker compose build --no-cache 8. localhost: 7474. 9."], ["10 - Neo4j_cleaned.txt_7", "Neo4j Browser localhost: 7474."], ["10 - Neo4j_cleaned.txt_8", "Then login. https://neo4j.com/docs/browser-manual/current/visual-tour/ 10."], ["10 - Neo4j_cleaned.txt_9", "Inserting Data by Creating Nodes CREATE (:User {name: \"Alice\", birthPlace: \"Paris\"}) CREATE (:User {name: \"Bob\", birthPlace: \"London\"}) CREATE (:User {name: \"Carol\", birthPlace: \"London\"}) CREATE (:User {name: \"Dave\", birthPlace: \"London\"}) CREATE (:User {name: \"Eve\", birthPlace: \"Rome\"}) 11."], ["10 - Neo4j_cleaned.txt_10", "Adding an Edge with No Variable Names CREATE (:User {name: \"Alice\", birthPlace: \"Paris\"}) CREATE (:User {name: \"Bob\", birthPlace: \"London\"}) MATCH (alice:User {name:\u201dAlice\u201d}) MATCH (bob:User {name: \u201cBob\u201d}) CREATE (alice)-[:KNOWS {since: \u201c2022-12-01\u201d}]->(bob) Note: Relationships are directed in neo4j. 12."], ["10 - Neo4j_cleaned.txt_11", "Matching Which users were born in London?"], ["10 - Neo4j_cleaned.txt_12", "MATCH (usr:User {birthPlace: \u201cLondon\u201d}) RETURN usr.name, usr.birthPlace 13."], ["10 - Neo4j_cleaned.txt_13", "Download Dataset and Move to Import Folder Clone this repo: https://github.com/PacktPublishing/Graph-Data-Science-with-Neo4j In Chapter02/data of data repo, unzip the netflix.zip file Copy netflix_titles.csv into the following folder where you put your docker compose file neo4j_db/neo4j_db/import 14."], ["10 - Neo4j_cleaned.txt_14", "Importing Data 15."], ["10 - Neo4j_cleaned.txt_15", "Basic Data Importing Type the following into the Cypher Editor in Neo4j Browser LOAD CSV WITH HEADERS FROM 'file:///netflix_titles.csv' AS line CREATE(:Movie { id: line.show_id, title: line.title, releaseYear: line.release_year } ) 16."], ["10 - Neo4j_cleaned.txt_16", "Loading CSVs - General Syntax LOAD CSV [WITH HEADERS] FROM 'file:///file_in_import_folder.csv' AS line [FIELDTERMINATOR ','] // do stuffs with 'line' 17."], ["10 - Neo4j_cleaned.txt_17", "Importing with Directors this Time LOAD CSV WITH HEADERS FROM 'file:///netflix_titles.csv' AS line WITH split(line.director, \",\") as directors_list UNWIND directors_list AS director_name CREATE (:Person {name: trim(director_name)}) But this generates duplicate Person nodes (a director can direct more than 1. movie) 18."], ["10 - Neo4j_cleaned.txt_18", "Importing with Directors Merged MATCH (p:Person) DELETE p LOAD CSV WITH HEADERS FROM 'file:///netflix_titles.csv' AS line WITH split(line.director, \",\") as directors_list UNWIND directors_list AS director_name MERGE (:Person {name: director_name}) 19."], ["10 - Neo4j_cleaned.txt_19", "Adding Edges LOAD CSV WITH HEADERS FROM 'file:///netflix_titles.csv' AS line MATCH (m:Movie {id: line.show_id}) WITH m, split(line.director, \",\") as directors_list UNWIND directors_list AS director_name MATCH (p:Person {name: director_name}) CREATE (p)-[:DIRECTED]->(m) 20."], ["10 - Neo4j_cleaned.txt_20", "Gut Check Let\u2019s check the movie titled Ray: MATCH (m:Movie {title: \"Ray\"})<-[:DIRECTED]-(p:Person) RETURN m, p 21. ?? 22"], ["05 - NoSQL Intro + KV DBs_cleaned.txt_0", "DS 4300."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_1", "NoSQL & KV DBs Mark Fontenot, PhD Northeastern University Some material used with permission from Dr."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_2", "Rachlin, with thanks! Distributed DBs and ACID - Pessimistic Concurrency \u25cf ACID transactions \u25cb Focuses on \u201cdata safety\u201d \u25cb considered a pessimistic concurrency model because it assumes one transaction has to protect itself from other transactions \u25a0 IOW, it assumes that if something can go wrong, it will. \u25cb Conflicts are prevented by locking resources until a transaction is complete (there are both read and write locks) \u25cb Write Lock Analogy \u2192 borrowing a book from a library\u2026 If you have it, no one else can."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_3", "See https://www.freecodecamp.org/news/how-databases-guarantee-isolation for more for a deeper dive. 2."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_4", "Optimistic Concurrency \u25cf Transactions do not obtain locks on data when they read or write \u25cf Optimistic because it assumes conflicts are unlikely to occur \u25cb Even if there is a conflict, everything will still be OK. \u25cf But how? \u25cb Add last update timestamp and version number columns to every table\u2026 read them when changing."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_5", "THEN, check at the end of transaction to see if any other transaction has caused them to be modified. 3."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_6", "Optimistic Concurrency \u25cf Low Conflict Systems (backups, analytical dbs, etc.) \u25cb Read heavy systems \u25cb the conflicts that arise can be handled by rolling back and re-running a transaction that notices a conflict. \u25cb So, optimistic concurrency works well - allows for higher concurrency \u25cf High Conflict Systems \u25cb rolling back and rerunning transactions that encounter a conflict \u2192 less efficient \u25cb So, a locking scheme (pessimistic model) might be preferable 4."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_7", "NoSQL - \u201cNoSQL\u201d first used in 1998. by Carlo Strozzi to describe his relational database system that did not use SQL. - More common, modern meaning is \u201cNot Only SQL\u201d - But, sometimes thought of as non-relational DBs - Idea originally developed, in part, as a response to processing unstructured web-based data. https://www.dataversity.net/a-brief-history-of-non-relational-databases/ 5."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_8", "CAP Theorem Review You can have 2, but not 3, of the following: - Consistency*: Every user of the DB has an identical view of the data at any given instant - Availability: In the event of a failure, the database system remains operational - Partition Tolerance: The database can maintain operations in the event of the network\u2019s failing between two segments of the distributed system * Note, the definition of Consistency in CAP is different from that of ACID."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_9", "Reference: https://alperenbayramoglu.com/posts/understanding-cap-theorem/ 6."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_10", "CAP Theorem Review - Consistency + Availability: System always responds with the latest data and every request gets a response, but may not be able to deal with network partitions - Consistency + Partition Tolerance: If system responds with data from the distrib. system, it is always the latest, else data request is dropped. - Availability + Partition Tolerance: System always sends are responds based on distributed store, but may not be the absolute latest data."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_11", "Reference: https://alperenbayramoglu.com/posts/understanding-cap-theorem/ 7."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_12", "ACID Alternative for Distrib Systems - BASE \u25cf Basically Available \u25cb Guarantees the availability of the data (per CAP), but response can be \u201cfailure\u201d/\u201cunreliable\u201d because the data is in an inconsistent or changing state \u25cb System appears to work most of the time 8."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_13", "ACID Alternative for Distrib Systems - BASE \u25cf Soft State - The state of the system could change over time, even w/o input."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_14", "Changes could be result of eventual consistency. \u25cb Data stores don\u2019t have to be write-consistent \u25cb Replicas don\u2019t have to be mutually consistent 9."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_15", "ACID Alternative for Distrib Systems - BASE \u25cf Eventual Consistency - The system will eventually become consistent \u25cb All writes will eventually stop so all nodes/replicas can be updated 10."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_16", "Categories of NoSQL DBs - Review 11."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_17", "First Up \u2192 Key-Value Databases 12."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_18", "Key Value Stores key = value - Key-value stores are designed around: - simplicity - the data model is extremely simple - comparatively, tables in a RDBMS are very complex. - lends itself to simple CRUD ops and API creation 13."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_19", "Key Value Stores key = value - Key-value stores are designed around: - speed - usually deployed as in-memory DB - retrieving a value given its key is typically a O(1) op b/c hash tables or similar data structs used under the hood - no concept of complex queries or joins\u2026 they slow things down 14."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_20", "Key Value Stores key = value - Key-value stores are designed around: - scalability - Horizontal Scaling is simple - add more nodes - Typically concerned with eventual consistency, meaning in a distributed environment, the only guarantee is that all nodes will eventually converge on the same value. 15."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_21", "KV DS Use Cases - EDA/Experimentation Results Store - store intermediate results from data preprocessing and EDA - store experiment or testing (A/B) results w/o prod db - Feature Store - store frequently accessed feature \u2192 low-latency retrieval for model training and prediction - Model Monitoring - store key metrics about performance of model, for example, in real-time inferencing. 16."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_22", "KV SWE Use Cases - Storing Session Information - everything about the current session can be stored via a single PUT or POST and retrieved with a single GET \u2026."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_23", "VERY Fast - User Profiles & Preferences - User info could be obtained with a single GET operation\u2026 language, TZ, product or UI preferences - Shopping Cart Data - Cart data is tied to the user - needs to be available across browsers, machines, sessions - Caching Layer: - In front of a disk-based database 17."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_24", "Redis DB - Redis (Remote Directory Server) - Open source, in-memory database - Sometimes called a data structure store - Primarily a KV store, but can be used with other models: Graph, Spatial, Full Text Search, Vector, Time Series - From db-engines.com Ranking of KV Stores: 18."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_25", "Redis - It is considered an in-memory database system, but\u2026 - Supports durability of data by: a) essentially saving snapshots to disk at specific intervals or b) append-only file which is a journal of changes that can be used for roll-forward if there is a failure - Originally developed in 2009. in C++ - Can be very fast \u2026 > 100, 000."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_26", "SET ops / second - Rich collection of commands - Does NOT handle complex data."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_27", "No secondary indexes."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_28", "Only supports lookup by Key. 19."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_29", "Redis Data Types Keys: - usually strings but can be any binary sequence Values: - Strings - Lists (linked lists) - Sets (unique unsorted string elements) - Sorted Sets - Hashes (string \u2192 string) - Geospatial data 20."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_30", "Setting Up Redis in Docker - In Docker Desktop, search for Redis. - Pull/Run the latest image (see above) - Optional Settings: add 6379. to Ports to expose that port so we can connect to it. - Normally, you would not expose the Redis port for security reasons - If you did this in a prod environment, major security hole. - Notice, we didn\u2019t set a password\u2026 21."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_31", "Connecting from DataGrip - File > New > Data Source > Redis - Give the Data Source a Name - Make sure the port is 6379. - Test the connection \u2705 22."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_32", "Redis Database and Interaction - Redis provides 16. databases by default - They are numbered 0. to 15. - There is no other name associated - Direct interaction with Redis is through a set of commands related to setting and getting k/v pairs (and variations) - Many language libraries available as well. 23."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_33", "Foundation Data Type - String - Sequence of bytes - text, serialized objects, bin arrays - Simplest data type - Maps a string to another string - Use Cases: - caching frequently accessed HTML/CSS/JS fragments - config settings, user settings info, token management - counting web page/app screen views OR rate limiting 24."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_34", "Some Initial Basic Commands - SET /path/to/resource 0."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_35", "SET user: 1. \u201cJohn Doe\u201d GET /path/to/resource EXISTS user: 1."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_36", "DEL user: 1."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_37", "KEYS user* - SELECT 5. - select a different database 25."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_38", "Some Basic Commands - SET someValue 0."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_39", "INCR someValue #increment by 1."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_40", "INCRBY someValue 10. #increment by 10."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_41", "DECR someValue #decrement by 1."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_42", "DECRBY someValue 5. #decrement by 5. - INCR parses the value as int and increments (or adds to value) - SETNX key value - only sets value to key if key does not already exist 26."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_43", "Hash Type - Value of KV entry is a collection of field-value pairs - Use Cases: - Can be used to represent basic objects/structures - number of field/value pairs per hash is 2^32- 1. - practical limit: available system resources (e.g. memory) - Session information management - User/Event tracking (could include TTL) - Active Session Tracking (all sessions under one hash key) 27."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_44", "Hash Commands HSET bike: 1. model Demios brand Ergonom price 1971."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_45", "HGET bike: 1. model HGET bike: 1. price HGETALL bike: 1."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_46", "HMGET bike: 1. model price weight What is returned?"], ["05 - NoSQL Intro + KV DBs_cleaned.txt_47", "HINCRBY bike: 1. price 100. 28."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_48", "List Type - Value of KV Pair is linked lists of string values - Use Cases: - implementation of stacks and queues - queue management & message passing queues (producer/consumer model) - logging systems (easy to keep in chronological order) - build social media streams/feeds - message history in a chat application - batch processing by queueing up a set of tasks to be executed sequentially at a later time 29."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_49", "Linked Lists Crash Course back front 10. nil - Sequential data structure of linked nodes (instead of contiguously allocated memory) - Each node points to the next element of the list (except the last one - points to nil/null) - O(1) to insert new value at front or insert new value at end 30."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_50", "List Commands - Queue Queue-like Ops LPUSH bikes:repairs bike: 1."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_51", "LPUSH bikes:repairs bike: 2."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_52", "RPOP bikes:repairs RPOP biles:repairs 31."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_53", "List Commands - Stack Stack-like Ops LPUSH bikes:repairs bike: 1."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_54", "LPUSH bikes:repairs bike: 2."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_55", "LPOP bikes:repairs LPOP biles:repairs 32."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_56", "List Commands - Others LPUSH mylist \u201cone\u201d LPUSH mylist \u201ctwo\u201d Other List Ops LPUSH mylist \u201cthree\u201d LLEN mylist LRANGE <key> <start> <stop> LRANGE mylist 0. 3."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_57", "LRANGE mylist 0. 0."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_58", "LRANGE mylist - 2. - 1. 33."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_59", "JSON Type - Full support of the JSON standard - Uses JSONPath syntax for parsing/navigating a JSON document - Internally, stored in binary in a tree-structure \u2192 fast access to sub elements 34."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_60", "Set Type - Unordered collection of unique strings (members) - Use Cases: - track unique items (IP addresses visiting a site, page, screen) - primitive relation (set of all students in DS4300) - access control lists for users and permission structures - social network friends lists and/or group membership - Supports set operations!! 35."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_61", "Set Commands SADD ds 4300. \u201cMark\u201d SADD ds 4300. \u201cSam\u201d SADD cs 3200. \u201cNick\u201d SADD cs 3200. \u201cSam\u201d SISMEMBER ds 4300. \u201cMark\u201d SISMEMBER ds 4300. \u201cNick\u201d SCARD ds 4300. 36."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_62", "SADD ds 4300. \u201cMark\u201d Set Commands SADD ds 4300. \u201cSam\u201d SADD cs 3200. \u201cNick\u201d SADD cs 3200. \u201cSam\u201d SCARD ds 4300."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_63", "SINTER ds 4300. cs 3200."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_64", "SDIFF ds 4300. cs 3200."], ["05 - NoSQL Intro + KV DBs_cleaned.txt_65", "SREM ds 4300. \u201cMark\u201d SRANDMEMBER ds 4300. 37. ?? 38"]]